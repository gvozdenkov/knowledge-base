# Семантика HTML5

До 2022 года ( +-год) в html5 было закреплено следующее:

- Глубина outline зависит от глубины вложенности секционных элементов.
- Каждый секционный элемент - "должен" иметь только один заголовок.
  Как следствие индекс у тега h (h1-h6) не имел НИКАКОГО влияния как на сам outline так и на значимость контента.

# Зачем же был нужен индекс у тега h1?

Это то самое с чего начались все проблемы outline в html5.

Из-за принятого решения, об обратной совместимости стандарта HTML5 со стандартом HTML4, требование: Каждый секционный элемент "должен" иметь только один заголовок, выдержать стало невозможным.
Так как семантика стандарта HTML4 допускала конструкции вида:

```html
<h1>Heading</h1>
<h2>Heading2</h2>

<!-- Что противоречило черновику семнатики HTML5 где тоже самое предпологалось делать так -->
<h1>Heading</h1>
<section>
  <h2>Heading2</h2>
</section>

<!-- или так -->

<h1>Heading</h1>
<section>
  <h1>Heading2</h1>
</section>
```

Использование более одного заголловка в одной секции было под запретом. Если бы не продавленное решение об обратной совместимости.

Как следствие возник вопрос - а как в рамках заявленной концепции семнатики HTML5 обрабатывать случай:

```html
<h1>Heading</h1>
<h2>Heading2</h2>
```

Секция одна, а заголовка два?

Простого решения не нашли и родили монстра - алгоритм построения неявных секций. Из за коотрого и завязался весь сыр бор.
Суть которого заключалась в том, что каждый заголовок, колличество которых больше одного в секции, порождает неявную секцию, то есть секцию которую явным образом не указывали

```html
<h1>Heading</h1>
<section>
  <h2>Heading2</h2>
</section>
```

И именно номер у тега h управлял тем - какая это будет секция по вложенности. Если номер больше - то секция вложенная. Если меньше или равен то секция вываливается из текущей секции.

Особенностей поведения у этого алогритмы очень много.

Как слдествие - у всех верстальщиков, кто занимался секмнатической версткой и понимал что и для чего он делает было СТРОГОЕ правило из черновика HTML5 - ОДНА секция - ОДИН заголовок.

При этом, шли дальше и принимали второе правмило - для удобства восприятия и верстки, у заголовка ставили индекс равный степени вложенности секций. Не смотря на то, что спецификация и допускала любой другой h.

Сам по себе этот алгоритм - просто сказка для семнатической верстки HTML решающая массу проблем и не создавай никаких труднойстей.... ЕСЛИ БЫ НЕ ПРИНЯТОЕ РЕШЕНИЕ О ОБРАТНОЙ СОВМЕСТИМОСТИ С HTML4

# Что случилось дальше

Больше 8 лет, мы жили с этим в качестве стандарта. Более того, где-то с 2016 года, поисковые алгоритмы гугл стали считать семнатическую верстку чем-то значимым - о чем на своих конференциях своими говорящими головами типа Мартина постоянно заявлось.

С этим безусловно что-то нужно было делать. Так как алгоритм построения неяваных секций - это ужас летащий на крыльях ночи. Это была самая большая ошибка за всю ситорию HTML5.

И этот вопрос решили ... уничтожив оригинальный алгоритм HTML5 для построения outline. Заменив его тем, что было в HTML4.
При этом сохранив алгоритм семнатики контента самого HTML5. То есть вложенность секций, как определение специфичности контента никто не отменял.

# Что из этого вышло?

Те кто правильно семнатически верстал - ничего не потерял и не приобрел.

Если мы следуем неписанному правилу - где уровень вложенности контента отвечает уровню у заголовка h то все как было так и осталось.

Проблемы только начались там, где нужно больше 6 заголовков. Но кого это волнует правда?

Особенно это не волнует тех кто использует семнатику HTML5 для решения задач органического поиска - т.к. гугл как строил связи контента по вложенностям секций так и строит. Как было ему плевать на h1-h6 так и стало плевать дальше.

# Что делать чтобы спасть спокойно?

Верстайте так как говорит HTML5 в черновике:

1. Одна секция один заголовок
2. Номер у h соотвествует уровню вложенности секций.

Так вы и рыбку сьели и на банане покатались.
